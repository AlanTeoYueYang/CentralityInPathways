}
if(min(beet.vec) == max(beet.vec)){
j <- j+1
next
} else{
beet.buckets <- cut(beet.vec,breaks = seq(min(beet.vec), max(beet.vec)
,len =21), include.lowest = TRUE)
levels(beet.buckets) <- 1:20
}
homo.path.info <- data_frame(pathway.name, total.node,total.edge,node.genes,
cent.vec, ssc.rank, ssc.norm, out.degree,
in.degree, all.degree, degree.rank,degree.norm,
beet.vec, beet.rank,beet.norm,
pgr.vec, pgr.rank, pgr.norm,
pgr.vec2, pgr.dbl.norm, pgr.dbl.rank,
pgr.vec3, pgr.und.norm, pgr.und.rank,
katz.vec, ktz.rank, ktz.norm,
ssc.buckets, beet.buckets, deg.buckets)
#homo.path.info %<>% filter(., node.genes %in% b$Gene) %>%
#    inner_join(.,b, by = c("node.genes" = "Gene"))
homo.path.info <- left_join(homo.path.info,b, by = c("node.genes" = "Gene"))
all.homo.essential <- rbind(all.homo.essential, homo.path.info)
temp <- all.path.names[[i]]
print(temp)
}
k
all.homo.essential <- data_frame()
all.path.names[166]
j <- 0
i <- 166
k <- 0
for (i in 1:length(graphs.homo)){
homo.Graph  <- graphs.homo[[i]]
if(paths.summary  %>% dplyr::select(., num_nodes) %>% slice(.,i) <20) next
if(paths.summary  %>% dplyr::select(., num_edges) %>% slice(.,i) <20) next
if(paths.summary %>% dplyr::select(., eigen) %>% slice(.,i) > 10)   next
node.genes   <- nodes(homo.Graph)
b            <- homo.gene.ref[homo.gene.ref$Gene %in% node.genes,]
# List of knockout genes from homo
homo.mat    <- as(homo.Graph,"matrix")
#Source/Sink Katz Centrality processing
cent.mat     <- newpath.centrality(homo.mat,alpha = 0.1, beta = 1)
cent.vec     <- rowSums(cent.mat$SSC)
ssc.rank     <- rank(cent.vec, ties.method = "min")
ssc.norm     <- zero.one.normalize(cent.vec)
#Degree Centrality processing
out.degree   <- rowSums(homo.mat)
in.degree    <- rowSums(t(homo.mat))
all.degree   <- in.degree + out.degree
degree.rank  <- rank(all.degree, ties.method = "min")
degree.norm  <- zero.one.normalize(all.degree)
#Betweenness Centrality Source
beet.vec     <- sna::betweenness(homo.mat, cmode = "directed")
beet.rank    <- rank(beet.vec, ties.method = "min")
beet.norm    <- zero.one.normalize(beet.vec)
#Betweenness Centrality Sink
beet.sink.vec     <- sna::betweenness(t(homo.mat), cmode = "directed")
beet.sink.rank    <- rank(beet.sink.vec, ties.method = "min")
beet.sink.norm    <- zero.one.normalize(beet.sink.vec)
#Betweenness Centrality Undirected
beet.und.vec     <- sna::betweenness((homo.mat), cmode = "undirected")
beet.und.rank    <- rank(beet.und.vec, ties.method = "min")
beet.und.norm    <- zero.one.normalize(beet.und.vec)
#PageRank Centrality
igraph.obj   <- igraph::graph_from_adjacency_matrix(homo.mat,mode = "directed")
igraph.obj2  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "directed")
igraph.obj3  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "undirected")
###Directed pageRank
pgr.vec      <- igraph::page.rank(igraph.obj,damping = 0.9)
pgr.vec      <- pgr.vec$vector
###Source-Sink pageRank
pgr.vec2     <- igraph::page.rank(igraph.obj2,damping = 0.9)
pgr.vec2     <- pgr.vec + pgr.vec2$vector
###Undirected pageRank
pgr.vec3     <- igraph::page.rank(igraph.obj3,damping = 0.9)
pgr.vec3     <- pgr.vec3$vector
pgr.rank     <- rank(pgr.vec,ties.method = "min")
pgr.norm     <- zero.one.normalize(pgr.vec)
pgr.dbl.norm <- zero.one.normalize(pgr.vec2)
pgr.dbl.rank <- rank(pgr.vec2,ties.method = "min")
pgr.und.norm <- zero.one.normalize(pgr.vec3)
pgr.und.rank <- rank(pgr.vec3,ties.method = "min")
# Katz Centrality
katz.mat     <- newpath.centrality((homo.mat),alpha = 0.1, beta = 0)
katz.vec     <- rowSums(katz.mat$Source)
ktz.rank     <- rank(katz.vec, ties.method = "min")
ktz.norm     <- zero.one.normalize(katz.vec)
# Semi Laplacian, heat diffusion kernel esque
tryCatch({
source.lap <- semi.laplace(homo.mat)
k <- k+1
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
#und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
} , error = function(e){print("err")}, finally = {print("Grrr")})
pathway.name <- all.path.names[[i]]
pathway.name <- rep(pathway.name,length(node.genes))
total.node   <- rep(length(node.genes),length(node.genes))
total.edge   <- pull(paths.summary %>% dplyr::select(., num_edges) %>% slice(.,i))
total.edge   <- rep(total.edge,length(node.genes))
# Some quality control
print(i)
if(as.character(min(cent.vec)) == as.character(max(cent.vec))){
j <- j+1
next
} else{
ssc.buckets  <- cut(cent.vec, breaks = seq(min(cent.vec),
max(cent.vec), len =21),include.lowest = TRUE)
levels(ssc.buckets) <- 1:20
}
if(as.character(min(all.degree)) == as.character(max(all.degree))){
j <- j+1
next
} else{deg.buckets  <- cut(all.degree,breaks = seq(min(all.degree), max(all.degree)
,len =21), include.lowest = TRUE)
levels(deg.buckets) <- 1:20
}
if(min(beet.vec) == max(beet.vec)){
j <- j+1
next
} else{
beet.buckets <- cut(beet.vec,breaks = seq(min(beet.vec), max(beet.vec)
,len =21), include.lowest = TRUE)
levels(beet.buckets) <- 1:20
}
homo.path.info <- data_frame(pathway.name, total.node,total.edge,node.genes,
cent.vec, ssc.rank, ssc.norm, out.degree,
in.degree, all.degree, degree.rank,degree.norm,
beet.vec, beet.rank,beet.norm,
pgr.vec, pgr.rank, pgr.norm,
pgr.vec2, pgr.dbl.norm, pgr.dbl.rank,
pgr.vec3, pgr.und.norm, pgr.und.rank,
katz.vec, ktz.rank, ktz.norm,
ssc.buckets, beet.buckets, deg.buckets)
#homo.path.info %<>% filter(., node.genes %in% b$Gene) %>%
#    inner_join(.,b, by = c("node.genes" = "Gene"))
homo.path.info <- left_join(homo.path.info,b, by = c("node.genes" = "Gene"))
all.homo.essential <- rbind(all.homo.essential, homo.path.info)
temp <- all.path.names[[i]]
print(temp)
}
k
all.homo.essential <- data_frame()
all.path.names[166]
j <- 0
i <- 166
k <- 0
for (i in 1:length(graphs.homo)){
homo.Graph  <- graphs.homo[[i]]
if(paths.summary  %>% dplyr::select(., num_nodes) %>% slice(.,i) <20) next
if(paths.summary  %>% dplyr::select(., num_edges) %>% slice(.,i) <20) next
if(paths.summary %>% dplyr::select(., eigen) %>% slice(.,i) > 10)   next
node.genes   <- nodes(homo.Graph)
b            <- homo.gene.ref[homo.gene.ref$Gene %in% node.genes,]
# List of knockout genes from homo
homo.mat    <- as(homo.Graph,"matrix")
#Source/Sink Katz Centrality processing
cent.mat     <- newpath.centrality(homo.mat,alpha = 0.1, beta = 1)
cent.vec     <- rowSums(cent.mat$SSC)
ssc.rank     <- rank(cent.vec, ties.method = "min")
ssc.norm     <- zero.one.normalize(cent.vec)
#Degree Centrality processing
out.degree   <- rowSums(homo.mat)
in.degree    <- rowSums(t(homo.mat))
all.degree   <- in.degree + out.degree
degree.rank  <- rank(all.degree, ties.method = "min")
degree.norm  <- zero.one.normalize(all.degree)
#Betweenness Centrality Source
beet.vec     <- sna::betweenness(homo.mat, cmode = "directed")
beet.rank    <- rank(beet.vec, ties.method = "min")
beet.norm    <- zero.one.normalize(beet.vec)
#Betweenness Centrality Sink
beet.sink.vec     <- sna::betweenness(t(homo.mat), cmode = "directed")
beet.sink.rank    <- rank(beet.sink.vec, ties.method = "min")
beet.sink.norm    <- zero.one.normalize(beet.sink.vec)
#Betweenness Centrality Undirected
beet.und.vec     <- sna::betweenness((homo.mat), cmode = "undirected")
beet.und.rank    <- rank(beet.und.vec, ties.method = "min")
beet.und.norm    <- zero.one.normalize(beet.und.vec)
#PageRank Centrality
igraph.obj   <- igraph::graph_from_adjacency_matrix(homo.mat,mode = "directed")
igraph.obj2  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "directed")
igraph.obj3  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "undirected")
###Directed pageRank
pgr.vec      <- igraph::page.rank(igraph.obj,damping = 0.9)
pgr.vec      <- pgr.vec$vector
###Source-Sink pageRank
pgr.vec2     <- igraph::page.rank(igraph.obj2,damping = 0.9)
pgr.vec2     <- pgr.vec + pgr.vec2$vector
###Undirected pageRank
pgr.vec3     <- igraph::page.rank(igraph.obj3,damping = 0.9)
pgr.vec3     <- pgr.vec3$vector
pgr.rank     <- rank(pgr.vec,ties.method = "min")
pgr.norm     <- zero.one.normalize(pgr.vec)
pgr.dbl.norm <- zero.one.normalize(pgr.vec2)
pgr.dbl.rank <- rank(pgr.vec2,ties.method = "min")
pgr.und.norm <- zero.one.normalize(pgr.vec3)
pgr.und.rank <- rank(pgr.vec3,ties.method = "min")
# Katz Centrality
katz.mat     <- newpath.centrality((homo.mat),alpha = 0.1, beta = 0)
katz.vec     <- rowSums(katz.mat$Source)
ktz.rank     <- rank(katz.vec, ties.method = "min")
ktz.norm     <- zero.one.normalize(katz.vec)
# Semi Laplacian, heat diffusion kernel esque
tryCatch({
#source.lap <- semi.laplace(homo.mat)
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
k <- k+1
} , error = function(e){print("err")}, finally = {print("Grrr")})
pathway.name <- all.path.names[[i]]
pathway.name <- rep(pathway.name,length(node.genes))
total.node   <- rep(length(node.genes),length(node.genes))
total.edge   <- pull(paths.summary %>% dplyr::select(., num_edges) %>% slice(.,i))
total.edge   <- rep(total.edge,length(node.genes))
# Some quality control
print(i)
if(as.character(min(cent.vec)) == as.character(max(cent.vec))){
j <- j+1
next
} else{
ssc.buckets  <- cut(cent.vec, breaks = seq(min(cent.vec),
max(cent.vec), len =21),include.lowest = TRUE)
levels(ssc.buckets) <- 1:20
}
if(as.character(min(all.degree)) == as.character(max(all.degree))){
j <- j+1
next
} else{deg.buckets  <- cut(all.degree,breaks = seq(min(all.degree), max(all.degree)
,len =21), include.lowest = TRUE)
levels(deg.buckets) <- 1:20
}
if(min(beet.vec) == max(beet.vec)){
j <- j+1
next
} else{
beet.buckets <- cut(beet.vec,breaks = seq(min(beet.vec), max(beet.vec)
,len =21), include.lowest = TRUE)
levels(beet.buckets) <- 1:20
}
homo.path.info <- data_frame(pathway.name, total.node,total.edge,node.genes,
cent.vec, ssc.rank, ssc.norm, out.degree,
in.degree, all.degree, degree.rank,degree.norm,
beet.vec, beet.rank,beet.norm,
pgr.vec, pgr.rank, pgr.norm,
pgr.vec2, pgr.dbl.norm, pgr.dbl.rank,
pgr.vec3, pgr.und.norm, pgr.und.rank,
katz.vec, ktz.rank, ktz.norm,
ssc.buckets, beet.buckets, deg.buckets)
#homo.path.info %<>% filter(., node.genes %in% b$Gene) %>%
#    inner_join(.,b, by = c("node.genes" = "Gene"))
homo.path.info <- left_join(homo.path.info,b, by = c("node.genes" = "Gene"))
all.homo.essential <- rbind(all.homo.essential, homo.path.info)
temp <- all.path.names[[i]]
print(temp)
}
k
i <- 10
homo.Graph  <- graphs.homo[[i]]
if(paths.summary  %>% dplyr::select(., num_nodes) %>% slice(.,i) <20) next
if(paths.summary  %>% dplyr::select(., num_edges) %>% slice(.,i) <20) next
if(paths.summary %>% dplyr::select(., eigen) %>% slice(.,i) > 10)   next
node.genes   <- nodes(homo.Graph)
b            <- homo.gene.ref[homo.gene.ref$Gene %in% node.genes,]
# List of knockout genes from homo
homo.mat    <- as(homo.Graph,"matrix")
#Source/Sink Katz Centrality processing
cent.mat     <- newpath.centrality(homo.mat,alpha = 0.1, beta = 1)
cent.vec     <- rowSums(cent.mat$SSC)
ssc.rank     <- rank(cent.vec, ties.method = "min")
ssc.norm     <- zero.one.normalize(cent.vec)
#Degree Centrality processing
out.degree   <- rowSums(homo.mat)
in.degree    <- rowSums(t(homo.mat))
all.degree   <- in.degree + out.degree
degree.rank  <- rank(all.degree, ties.method = "min")
degree.norm  <- zero.one.normalize(all.degree)
#Betweenness Centrality Source
beet.vec     <- sna::betweenness(homo.mat, cmode = "directed")
beet.rank    <- rank(beet.vec, ties.method = "min")
beet.norm    <- zero.one.normalize(beet.vec)
#Betweenness Centrality Sink
beet.sink.vec     <- sna::betweenness(t(homo.mat), cmode = "directed")
beet.sink.rank    <- rank(beet.sink.vec, ties.method = "min")
beet.sink.norm    <- zero.one.normalize(beet.sink.vec)
#Betweenness Centrality Undirected
beet.und.vec     <- sna::betweenness((homo.mat), cmode = "undirected")
beet.und.rank    <- rank(beet.und.vec, ties.method = "min")
beet.und.norm    <- zero.one.normalize(beet.und.vec)
#PageRank Centrality
igraph.obj   <- igraph::graph_from_adjacency_matrix(homo.mat,mode = "directed")
igraph.obj2  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "directed")
igraph.obj3  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "undirected")
###Directed pageRank
pgr.vec      <- igraph::page.rank(igraph.obj,damping = 0.9)
pgr.vec      <- pgr.vec$vector
###Source-Sink pageRank
pgr.vec2     <- igraph::page.rank(igraph.obj2,damping = 0.9)
pgr.vec2     <- pgr.vec + pgr.vec2$vector
###Undirected pageRank
pgr.vec3     <- igraph::page.rank(igraph.obj3,damping = 0.9)
pgr.vec3     <- pgr.vec3$vector
pgr.rank     <- rank(pgr.vec,ties.method = "min")
pgr.norm     <- zero.one.normalize(pgr.vec)
pgr.dbl.norm <- zero.one.normalize(pgr.vec2)
pgr.dbl.rank <- rank(pgr.vec2,ties.method = "min")
pgr.und.norm <- zero.one.normalize(pgr.vec3)
pgr.und.rank <- rank(pgr.vec3,ties.method = "min")
# Katz Centrality
katz.mat     <- newpath.centrality((homo.mat),alpha = 0.1, beta = 0)
katz.vec     <- rowSums(katz.mat$Source)
ktz.rank     <- rank(katz.vec, ties.method = "min")
ktz.norm     <- zero.one.normalize(katz.vec)
# Semi Laplacian, heat diffusion kernel esque
tryCatch({
#source.lap <- semi.laplace(homo.mat)
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
k <- k+1
} , error = function(e){print("err")}, finally = {print("Grrr")})
#source.lap <- semi.laplace(homo.mat)
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
igraph::as_adj(igraph.obj3,sparse = F)
#source.lap <- semi.laplace(homo.mat)
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
igraph.obj3
as_adj(igraph.obj3, sparse = F)
some.Matrix <- as_adj(igraph.obj3, sparse = F)
some.Matrix
inv.diag <- 1/rowSums(some.Matrix)
inv.diag[!is.finite(inv.diag)] <- 0
(diag(inv.diag) %*% some.Matrix)
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
norm.laplace.esque
#norm.laplace.esque <-  Ginv(norm.laplace.esque)
norm.laplace.esque <-  solve(norm.laplace.esque)
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
eigen(norm.laplace.esque)
eigen(norm.laplace.esque,only.values = T)
#norm.laplace.esque <-  Ginv(norm.laplace.esque)
norm.laplace.esque <-  solve(norm.laplace.esque)
### Semi laplace calculator, works with normalized connectivty matrix
semi.laplace <- function(some.Matrix){
inv.diag <- 1/rowSums(some.Matrix)
inv.diag[!is.finite(inv.diag)] <- 0
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
#norm.laplace.esque <-  Ginv(norm.laplace.esque)
norm.laplace.esque <-  solve(norm.laplace.esque)
return(rowSums(norm.laplace.esque))
}
k <- 0
all.homo.essential <- data_frame()
k <- 0
for (i in 1:length(graphs.homo)){
homo.Graph  <- graphs.homo[[i]]
if(paths.summary  %>% dplyr::select(., num_nodes) %>% slice(.,i) <20) next
if(paths.summary  %>% dplyr::select(., num_edges) %>% slice(.,i) <20) next
if(paths.summary %>% dplyr::select(., eigen) %>% slice(.,i) > 10)   next
node.genes   <- nodes(homo.Graph)
b            <- homo.gene.ref[homo.gene.ref$Gene %in% node.genes,]
# List of knockout genes from homo
homo.mat    <- as(homo.Graph,"matrix")
#Source/Sink Katz Centrality processing
cent.mat     <- newpath.centrality(homo.mat,alpha = 0.1, beta = 1)
cent.vec     <- rowSums(cent.mat$SSC)
ssc.rank     <- rank(cent.vec, ties.method = "min")
ssc.norm     <- zero.one.normalize(cent.vec)
#Degree Centrality processing
out.degree   <- rowSums(homo.mat)
in.degree    <- rowSums(t(homo.mat))
all.degree   <- in.degree + out.degree
degree.rank  <- rank(all.degree, ties.method = "min")
degree.norm  <- zero.one.normalize(all.degree)
#Betweenness Centrality Source
beet.vec     <- sna::betweenness(homo.mat, cmode = "directed")
beet.rank    <- rank(beet.vec, ties.method = "min")
beet.norm    <- zero.one.normalize(beet.vec)
#Betweenness Centrality Sink
beet.sink.vec     <- sna::betweenness(t(homo.mat), cmode = "directed")
beet.sink.rank    <- rank(beet.sink.vec, ties.method = "min")
beet.sink.norm    <- zero.one.normalize(beet.sink.vec)
#Betweenness Centrality Undirected
beet.und.vec     <- sna::betweenness((homo.mat), cmode = "undirected")
beet.und.rank    <- rank(beet.und.vec, ties.method = "min")
beet.und.norm    <- zero.one.normalize(beet.und.vec)
#PageRank Centrality
igraph.obj   <- igraph::graph_from_adjacency_matrix(homo.mat,mode = "directed")
igraph.obj2  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "directed")
igraph.obj3  <- igraph::graph_from_adjacency_matrix(t(homo.mat),mode = "undirected")
###Directed pageRank
pgr.vec      <- igraph::page.rank(igraph.obj,damping = 0.9)
pgr.vec      <- pgr.vec$vector
###Source-Sink pageRank
pgr.vec2     <- igraph::page.rank(igraph.obj2,damping = 0.9)
pgr.vec2     <- pgr.vec + pgr.vec2$vector
###Undirected pageRank
pgr.vec3     <- igraph::page.rank(igraph.obj3,damping = 0.9)
pgr.vec3     <- pgr.vec3$vector
pgr.rank     <- rank(pgr.vec,ties.method = "min")
pgr.norm     <- zero.one.normalize(pgr.vec)
pgr.dbl.norm <- zero.one.normalize(pgr.vec2)
pgr.dbl.rank <- rank(pgr.vec2,ties.method = "min")
pgr.und.norm <- zero.one.normalize(pgr.vec3)
pgr.und.rank <- rank(pgr.vec3,ties.method = "min")
# Katz Centrality
katz.mat     <- newpath.centrality((homo.mat),alpha = 0.1, beta = 0)
katz.vec     <- rowSums(katz.mat$Source)
ktz.rank     <- rank(katz.vec, ties.method = "min")
ktz.norm     <- zero.one.normalize(katz.vec)
# Semi Laplacian, heat diffusion kernel esque
tryCatch({
#source.lap <- semi.laplace(homo.mat)
#sink.lap   <- semi.laplace(t(homo.mat))
#ssc.lap    <- source.lap + sink.lap
und.lap    <- semi.laplace(igraph::as_adj(igraph.obj3,sparse = F))
k <- k+1
} , error = function(e){print("err")}, finally = {print("Grrr")})
pathway.name <- all.path.names[[i]]
pathway.name <- rep(pathway.name,length(node.genes))
total.node   <- rep(length(node.genes),length(node.genes))
total.edge   <- pull(paths.summary %>% dplyr::select(., num_edges) %>% slice(.,i))
total.edge   <- rep(total.edge,length(node.genes))
# Some quality control
print(i)
if(as.character(min(cent.vec)) == as.character(max(cent.vec))){
j <- j+1
next
} else{
ssc.buckets  <- cut(cent.vec, breaks = seq(min(cent.vec),
max(cent.vec), len =21),include.lowest = TRUE)
levels(ssc.buckets) <- 1:20
}
if(as.character(min(all.degree)) == as.character(max(all.degree))){
j <- j+1
next
} else{deg.buckets  <- cut(all.degree,breaks = seq(min(all.degree), max(all.degree)
,len =21), include.lowest = TRUE)
levels(deg.buckets) <- 1:20
}
if(min(beet.vec) == max(beet.vec)){
j <- j+1
next
} else{
beet.buckets <- cut(beet.vec,breaks = seq(min(beet.vec), max(beet.vec)
,len =21), include.lowest = TRUE)
levels(beet.buckets) <- 1:20
}
homo.path.info <- data_frame(pathway.name, total.node,total.edge,node.genes,
cent.vec, ssc.rank, ssc.norm, out.degree,
in.degree, all.degree, degree.rank,degree.norm,
beet.vec, beet.rank,beet.norm,
pgr.vec, pgr.rank, pgr.norm,
pgr.vec2, pgr.dbl.norm, pgr.dbl.rank,
pgr.vec3, pgr.und.norm, pgr.und.rank,
katz.vec, ktz.rank, ktz.norm,
ssc.buckets, beet.buckets, deg.buckets)
#homo.path.info %<>% filter(., node.genes %in% b$Gene) %>%
#    inner_join(.,b, by = c("node.genes" = "Gene"))
homo.path.info <- left_join(homo.path.info,b, by = c("node.genes" = "Gene"))
all.homo.essential <- rbind(all.homo.essential, homo.path.info)
temp <- all.path.names[[i]]
print(temp)
}
k
i <- 10
homo.Graph  <- graphs.homo[[i]]
if(paths.summary  %>% dplyr::select(., num_nodes) %>% slice(.,i) <20) next
if(paths.summary  %>% dplyr::select(., num_edges) %>% slice(.,i) <20) next
if(paths.summary %>% dplyr::select(., eigen) %>% slice(.,i) > 10)   next
node.genes   <- nodes(homo.Graph)
b            <- homo.gene.ref[homo.gene.ref$Gene %in% node.genes,]
# List of knockout genes from homo
homo.mat    <- as(homo.Graph,"matrix")
homo.mat
homo.mat + t(homo.mat)
inv.diag <- 1/rowSums(homo.mat)
inv.diag[!is.finite(inv.diag)] <- 0
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
eigen(norm.laplace.esque,only.values = T)
homo.mat <- homo.mat + t(homo.mat)
homo.mat
homo.mat >1
homo.mat > 0
homo.mat[homo.mat > 0 ] <- 1
homo.mat
inv.diag <- 1/rowSums(homo.mat)
inv.diag[!is.finite(inv.diag)] <- 0
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
eigen(norm.laplace.esque,only.values = T)
#norm.laplace.esque <-  Ginv(norm.laplace.esque)
norm.laplace.esque <-  solve(norm.laplace.esque)
norm.laplace.esque <-  Ginv(norm.laplace.esque)
norm.laplace.esque
eigen((diag(inv.diag) %*% some.Matrix),only.values = T)
norm.laplace.esque <-  diag(1,length(inv.diag)) - 0.999* (diag(inv.diag) %*% some.Matrix)
norm.laplace.esque <-  solve(norm.laplace.esque)
norm.laplace.esque
0.999 * (diag(inv.diag) %*% some.Matrix)
norm.laplace.esque <-  diag(1,length(inv.diag)) - (diag(inv.diag) %*% some.Matrix)
eigen((diag(inv.diag) %*% some.Matrix),only.values = T)
norm.laplace.esque <-  solve(norm.laplace.esque)
norm.laplace.esque <-  solve((diag(inv.diag) %*% some.Matrix))
norm.laplace.esque <-  solve(some.Matrix))
norm.laplace.esque <-  solve(some.Matrix)
some.Matrix
igraph::components(igraph.obj3)
